#!/usr/bin/env python3
"""
embed_shaders.py - Script to embed GLSL shader sources into C++ header files

This script reads GLSL shader files and embeds them as string literals
in a C++ header file, allowing shaders to be distributed with the library
without requiring separate shader files at runtime.
"""

import os
import sys
import argparse
from typing import List


def process_shader_file(file_path: str) -> str:
    """
    Read and process a GLSL shader file, converting it to a C++ string literal.
    
    Args:
        file_path: Path to the GLSL shader file
        
    Returns:
        C++ string literal containing the shader source
    """
    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # Remove comments to reduce size
    lines = content.split('\n')
    processed_lines = []
    in_multiline_comment = False
    
    for line in lines:
        stripped = line.strip()
        
        # Skip single line comments
        if stripped.startswith('//'):
            continue
            
        # Handle multiline comments
        if '/*' in stripped and '*/' not in stripped:
            in_multiline_comment = True
            continue
        elif '*/' in stripped:
            in_multiline_comment = False
            continue
        
        if in_multiline_comment:
            continue
            
        # Add the line if it's not empty after stripping
        if stripped:
            processed_lines.append(line.rstrip())
    
    processed_content = '\n'.join(processed_lines)
    
    # Escape C++ string literals
    escaped_content = processed_content.replace('\\', '\\\\')
    escaped_content = escaped_content.replace('"', '\\"')
    escaped_content = escaped_content.replace('\n', '\\n')
    
    return f'"{escaped_content}"'


def generate_shader_header(shader_files: List[str]) -> str:
    """
    Generate the C++ header content from shader files.
    
    Args:
        shader_files: List of shader file paths
        
    Returns:
        Complete C++ header file content
    """
    header = '''#pragma once

/**
 * @file shaders.h
 * @brief Embedded GLSL shader sources
 * 
 * This file contains embedded GLSL shader sources generated by embed_shaders.py.
 * Do not edit this file directly - modify the source .vert/.frag/.comp files instead.
 */

#include <unordered_map>
#include <string>

namespace earth_map {{
namespace shaders {'''

    shader_map = {}
    
    for shader_file in shader_files:
        if not os.path.exists(shader_file):
            print(f"Warning: Shader file not found: {shader_file}", file=sys.stderr)
            continue
            
        # Generate variable name from file path
        rel_path = os.path.relpath(shader_file)
        var_name = rel_path.replace('/', '_').replace('.', '_').replace('-', '_').upper()
        
        # Get shader content
        shader_content = process_shader_file(shader_file)
        
        # Add to header
        header += f'''
// {rel_path}
static const char* {var_name} = {shader_content};'''
        
        # Add to map
        shader_map[var_name] = rel_path

    # Add function to get shader by filename
    header += '''

/**
 * @brief Get embedded shader source by filename
 * 
 * @param filename Relative shader filename
 * @return const char* Shader source code, or nullptr if not found
 */
inline const char* GetShader(const std::string& filename) {'''
    
    for var_name, filename in shader_map.items():
        header += f'''
    if (filename == "{filename}") {{
        return {var_name};
    }}'''
    
    header += '''
    return nullptr;
}

/**
 * @brief Get all available shader filenames
 * 
 * @return std::vector<std::string> List of embedded shader filenames
 */
inline std::vector<std::string> GetAvailableShaders() {'''
    
    if shader_map:
        header += f'''
    return {{'''
        header += ', '.join(f'"{filename}"' for filename in shader_map.values())
        header += '''};'''
    else:
        header += '''
    return {};'''
    
    header += '''
}

} // namespace shaders
} // namespace earth_map'''

    return header


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description='Embed GLSL shaders into C++ header')
    parser.add_argument('shader_files', nargs='+', help='GLSL shader files to embed')
    parser.add_argument('output_header', help='Output C++ header file')
    parser.add_argument('--validate', action='store_true', 
                       help='Validate shader syntax using glslangValidator if available')
    
    args = parser.parse_args()
    
    # Validate shaders if requested
    if args.validate:
        for shader_file in args.shader_files:
            if os.path.exists(shader_file):
                try:
                    import subprocess
                    result = subprocess.run(['glslangValidator', '--stdin', shader_file], 
                                          capture_output=True, text=True)
                    if result.returncode != 0:
                        print(f"Warning: Shader validation failed for {shader_file}:")
                        print(result.stderr, file=sys.stderr)
                except FileNotFoundError:
                    print("glslangValidator not found, skipping validation", file=sys.stderr)
    
    # Generate header content
    header_content = generate_shader_header(args.shader_files)
    
    # Write output file
    os.makedirs(os.path.dirname(args.output_header), exist_ok=True)
    with open(args.output_header, 'w', encoding='utf-8') as f:
        f.write(header_content)
    
    print(f"Generated {args.output_header} with {len(args.shader_files)} shaders")


if __name__ == '__main__':
    main()